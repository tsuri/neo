#+TITLE: Emacs Configuration
#+DESCRIPTION: An org-babel based emacs configuration I find useful
#+LANGUAGE: en
#+PROPERTY: results silent

This piece of emacs lisp is temporary only while I play with a
pre-release of Emacs 28, with and without native compilation support.

#+begin_src emacs-lisp
(message system-configuration-options)

(message system-configuration-features)

(if (functionp 'json-serialize)
  (message "Native JSON is available")
(message "Native JSON is *not* available"))

(if (and (fboundp 'native-comp-available-p)
       (native-comp-available-p))
  (message "Native compilation is available")
(message "Native complation is *not* available"))
#+end_src

* Introduction
  This is my personal Emacs configuration. This is not the first time
  I declare [[https://www.emacswiki.org/emacs/DotEmacsBankruptcy][Emacs bankrupcy]] and start over with a new emacs life.

  It is not intended to be general or beginner-friendly. If you're a
  beginner you'll probably be better off with one of the many emacs
  configurations with batteries included.

  Also, my Emacs stays on for weeks or months at a time; I'm not
  interested in reducing startup time or delaying loading of packages
  until they're first used. It simply doesn't affect me.  This is
  another motif for looking somewhere else. Distributions like
  spacemacs or doom spend quite a lot of time in making startup fast,
  you'll be appier with them.

  If you're still with me, you still probably shouldn't take this
  configuration in its entirety. Rather, cherry pick parts you find
  interesting and port them to your own configuration.

  /Abandon All Hope, Ye Who Enter Here/

  
* General
** System Configuration
** Emacs Startup
When testing changes to the Emacs configuration it is useful to
be able to restart Emacs from within Emacs. The following allows to
restart Emacs when C-x C-c (normally bound to save-buffers-kill-Emacs)
is invoked with a universal argument.

Note that when we restart Emacs, all open files and frames are
restored (courtesy of the desktop package if installed). We also retrieve the
initial command line arguments. ~restart-emacs~ doesn't do this as
there's no platform independent way for doing it. Note that
~command-line-args~ is not sufficient as many arguments are deleted
while being processed by the Emacs C code (for instance ~--debug-init~ )
I'd still think that it would be better than completely ignoring them,
but I'm not the author of the ~~restart-emacs~ package. Here I collect
arguments from the ~/proc~ file system, I only care about Linux anyhow.

#+BEGIN_SRC emacs-lisp
  (defun neo/emacs-args ()
    (with-temp-buffer
      (insert-file-contents "/proc/self/cmdline")
      (split-string (buffer-string) "\0" t)))

  (defun neo/restart-emacs-or-exit (arg)
    (interactive "P")
    (if arg
        (restart-emacs (cdr (neo/emacs-args)))
      (save-buffers-kill-emacs)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :bind
    ("C-x C-c" . neo/restart-emacs-or-exit))
#+END_SRC
** Package Configurations
We use ~straight.el~ for package installation, but ~use-package~ for
configuration. Here we setup a few useful extensions.

The modeline becomes unwieldy when lot of minor modes try to say
things there. We were using ~diminish~, but it seems that now
~delight~ can completely replace it.

#+begin_src emacs-lisp
  (use-package delight)
#+end_src

In theory, this package is deprecated and the functionality built-in
into ~use-package~. In practice, without it I cannot get the ~:chords~
keyword to work.

#+begin_src emacs-lisp
  (use-package use-package-chords
    :config (key-chord-mode 1))
#+end_src

  
#+begin_src emacs-lisp
    (use-package emacs
      :delight
      (org-indent-mode)
      (auto-revert-mode " AR")
      (auto-fill-function " AF"))
#+end_src

** Reasonable Defaults
Speaking only for myself, claro?

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq message-log-max 10000) ; I cannot have t as my Emacs stays on forever
    (setq kill-whole-line t)
    (setq visible-bell 1)
    (setq initial-scratch-message "")
    (setq inhibit-splash-screen t)
    (setq inhibit-startup-screen t)
    (setq inhibit-startup-buffer-menu t)
    (setq use-dialog-box nil)
    (setq ring-bell-function 'ignore)
    (setq-default truncate-lines t)
    (setq custom-safe-themes t) ; not sure, I'll probaby use very few themes no need to trust 'em all
    (put 'narrow-to-region 'disabled nil)
    (tool-bar-mode -1)
    (toggle-scroll-bar -1)
    (toggle-menu-bar-mode-from-frame -1)
    (tooltip-mode -1)
    (blink-cursor-mode 0)
    (set-fringe-mode '(10 . 0))
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Save Areas

Emacs (and emacs packages) tend to store lot of files in the .emacs.d directory. This wouldn't be
particularly problematic if it wasn't for the fact that my .emacs-*.d is also a git repository. It is
possible to ignore files in git, but it become annoying to have to modify .gitignore just because I
tried a new package. So we will move everything to a ~.save~ directory.

Most of this will be accomplished by the ~no-litter~ package, but we initialize here a few variables
so that the same places can be used by other packages no-litter knows nothing about.

*** Garbage
There is no such thing as garbage, just useful stuff in the wrong place.
I wan tit out of my emacs configuration.

#+begin_src emacs-lisp
  (use-package no-littering
    :init
    ;; Still debating whether these dirs should be per-distro.
    ;(setq no-littering-etc-directory (expand-file-name "~/.emacs-save.d/config"))
    ;(setq no-littering-var-directory (expand-file-name "~/.emacs-save.d/data"))
    (setq no-littering-etc-directory (neo/litter-directory "config"))
    (setq no-littering-var-directory (neo/litter-directory "data"))
    (setq custom-file (expand-file-name "custom.el" no-littering-var-directory)))
#+end_src

*** Autosave
**** Files
By default autosave files are saved in the same directory of the file
they're related to (I think the exception is that remote files are
saved in some local temporary directory). I find this annoying, so I
put them together with the other "garbage".
Autosave files are ephemeral and are deleted when a buffer is saved in
its visited file (by default, but I don't see a reason for changing
that), otherwise it would make sense to discuss whether the git branch
shoud be part of the autosave file name.
#+begin_src emacs-lisp
  :init
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+end_src

**** History
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (savehist-mode))
#+end_src

*** Backups

These is my configuration for backups. The directory itself is set by
no-littering.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq backup-by-copying t)
    (setq delete-old-versions t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 2)
    (setq version-control t))
#+end_src

*** Destop Save

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq desktop-save t)
    (desktop-save-mode 1))
#+END_SRC
*** Variables

I persist global variables by adding them to
~deskop-globals-to-save~. I could have used savehist for this.

** Native Compilation

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (when (boundp 'native-comp-eln-load-path)
      (add-to-list 'native-comp-eln-load-path (neo/litter-directory "eln" emacs-version)))
    (setq native-comp-async-report-warnings-errors 'silent))
#+end_src

  This is for native compilation. Should probably go in
  ~early-init.org~ once we have it. After I figure out what actually
  goes inside ~early-init.el~, maybe it is strictly for before-gui
  things.
  
#+begin_src emacs-lisp
    (if (and (fboundp 'native-comp-available-p)
             (native-comp-available-p))
        (progn
          (message "Native compilation is available")
          (setq comp-deferred-compilation t)
          (setq package-native-compile t)
          (setq native-comp-async-query-on-exit t)
          (setq native-comp-async-jobs-number 0) ; use half of the cores
          (setq native-comp-async-report-warnings-errors nil)
          (setq comp-async-report-warnings-errors nil))
      (message "Native complation is *not* available"))
#+end_src

** Secrets
** Misc
* Completion

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :delight
    )
#+END_SRC

#+begin_src emacs-lisp
  (use-package ivy-rich
    :after all-the-icons-ivy-rich
    :config
    (setq ivy-rich--original-display-transformers-list nil)  ;; needs to be set otherwise (ivy-rich-set-display-transformer) does not get called
    (ivy-set-display-transformer 'ivy-switch-buffer
				 'ivy-rich-switch-buffer-transformer)
    (setq-default ivy-rich-path-style 'abbrev
		  ivy-virtual-abbreviate 'full
		  ivy-rich-switch-buffer-align-virtual-buffer t)
    (ivy-rich-mode 1))
#+end_src

#+begin_src emacs-lisp
    (use-package counsel
      :config
      (ivy-mode 1)
      :bind
      ("<f2> f" . 'counsel-describe-function)
  ;    ("<f2> F" . 'list-faces-display)
      ("<f2> k" . describe-personal-keybindings)
      ("<f2> v" . 'counsel-describe-variable)
      ("<f2> o" . 'counsel-describe-symbol)
      ("<f2> l" . 'counsel-find-library)
      ("<f2> t" . 'neo/load-theme)	; for now, later we'll have a hydra/transient thing
      ("<f2> u" . 'counsel-unicode-char))
#+end_src

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :after ivy
    :config
    (setq all-the-icons-ivy-rich-color-icon t)
    (setq all-the-icons-ivy-rich-icon-size 1.0)
    (setq all-the-icons-ivy-rich-project t)
    (all-the-icons-ivy-rich-mode 1))
#+end_src



#+begin_src emacs-lisp
  (use-package prescient)
#+end_src

#+begin_src emacs-lisp
  (use-package ivy-prescient
    :after counsel
    :config
    (ivy-prescient-mode 1)
    (prescient-persist-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package company
    :delight
    :bind (:map company-active-map
           ("TAB" . company-complexivte-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :custom
    (company-require-match 'never)
    (company-minimum-prefix-length 2)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 60))
#+end_src

#+begin_src emacs-lisp
  (use-package company-prescient
    :after company
    :config
    (company-prescient-mode 1))
#+end_src

* User Interface
** Appearance
*** Themes

**** Theme Switching
Emacs doesn't have a hook on theme changes, mainly because it is not
easy to define precisely what a theme switch is. Yet, we have a few
uses for a reasonable approximation, here it is:

#+begin_src emacs-lisp 
   (defvar neo/current-theme 'doom-tomorrow-day "Theme applied")
   (push 'neo/current-theme desktop-globals-to-save)
#+end_src

#+begin_src emacs-lisp
  (defun neo/load-theme ()
    (interactive)
    (ivy-read "Load custom theme: "
              (mapcar 'symbol-name
                      (custom-available-themes))
              :action #'neo/load-theme-internal
              :caller 'neo/load-theme))
  #+end_src

  #+begin_src emacs-lisp
    ;;; need to do something fr powerline nd other modelines
    (defun neo/load-theme-action (x)
    (condition-case nil
        (progn
          (mapc #'disable-theme custom-enabled-themes)
          (load-theme-internal (intern x) t))
      (error "Problem loading theme %s" x)))
#+end_src

#+begin_src emacs-lisp
      (defun neo/update-x-defaults ()
        (with-temp-file "~/.Xdefaults"
          (let ((foreground (face-attribute 'default :foreground))
                (background (face-attribute 'default :background)))
            (insert "emacs.fullscreen: maximized\n")
            (insert (format "emacs.background: %s\n" background))
            (insert (format "emacs.foreground: %s\n" foreground))))
        (call-process-shell-command "xrdb -load ~/.Xdefaults" nil 0))
      
;      (add-hook 'emacs-kill-hook 'neo/update-x-defaults)
#+end_src

#+begin_src emacs-lisp
  (defun neo/load-theme-internal (theme)
    (let ((theme (if (stringp theme) (intern theme) theme)))
      (message "Loading theme %s (disabling others)" theme)
      (mapc #'disable-theme custom-enabled-themes)
      (setq neo/current-theme theme)
      (load-theme theme t)
      (neo/update-x-defaults)
      ;; We should really change the foreground only when org-hide-leading-stars is t.
      ;; For me this is always true
      (set-face-foreground 'org-superstar-leading (face-attribute 'default :background))
      (set-face-foreground 'org-hide (face-attribute 'default :background))))
  
#+end_src

#+begin_src emacs-lisp
  (add-hook 'desktop-after-read-hook (lambda () (neo/load-theme-internal neo/current-theme)))
#+end_src
  
**** Themes

#+begin_src emacs-lisp
  (use-package doom-themes)
#+end_src

#+begin_src emacs-lisp
  (use-package modus-themes)  
#+end_src

#+begin_src emacs-lisp
  (use-package twilight-theme)
#+end_src

#+begin_src emacs-lisp
  (use-package molokai-theme)  
#+end_src

#+begin_src emacs-lisp
  (use-package dracula-theme)  
#+end_src

#+begin_src emacs-lisp
  (use-package blackboard-theme)
#+end_src


*** Modeline
*** Icons
*** Eyecandies
** Keybindings
*** Memory Aids
There are a few keybindings in Emacs. Some are useful, and you won't
remember them when needed.

At times one remembers the beginning of a keybinding. ~which-key~ comes
to the rescue and after a short delay shows all possible ways to
extend that prefix. Not as precise as curated hydras, but has the big
advantage of applying to all key bindings without further
configuration.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :delight which-key-mode
  :config
  (setq which-key-idle-delay 0.3))
#+END_SRC

And remember the
~describe-personal-keybindings~
(~~<f2> k~~) that comes with ~use-package~.

*** Global Keybindings

* Movement

* Undo
Friends don't let friends use Emacs' builtin undo.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :delight undo-tree-mode
    :chords (("uu" . undo-tree-visualize))
    :init (global-undo-tree-mode)
    (setq undo-tree-visualizer-diff t)
    (setq undo-tree-visualizer-timestamps t))
#+END_SRC

* Software Development

** Version Control

*** Git

#+begin_src emacs-lisp
(use-package git-timemachine :bind ("<f12> t" . 'git-timemachine))
#+end_src

#+begin_src emacs-lisp
;  (use-package git-gutter+
;    :config (global-git-gutter+-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package git-gutter-fringe+) ; :after git-gutter+)
#+end_src

#+begin_src emacs-lisp
  (use-package dired-git-info
    :bind (:map dired-mode-map
           (")" . dired-git-info-mode)))
#+end_src


*** Magit
I use magit for interacting with git repositories. And I'm forcing
myself to use the command line git as little as possible.
#+begin_src emacs-lisp
  (use-package magit
    :config
    (setq magit-save-repository-buffers 'dontask)
    :custom
    (magit-list-refs-sortby "-creatordate") ; doesn't seem to have any effect
    (magit-refs-show-commit-count 'branch) ; may be too expensive
    ; TODO: this should be the default behavior of magit-builtin-completing-read
    ; when ivy is enabed gobally. But I am not sure of what is the actual situation.
    (magit-completing-read-function 'ivy-completing-read)
    :init
    ;; NOTE: order of functions in this hook is important, we make this clear with setq
    ;; instead of gambling with add-hook. There's magit-add-section-hook that might be better.
    ;; TODO: find the right place for magit-insert-branch-description (might also be
    ;; useful in magit-refs-sections-hook)
    (setq magit-status-sections-hook
	  '(magit-insert-status-headers
	    magit-insert-merge-log
	    magit-insert-rebase-sequence
	    magit-insert-am-sequence
	    magit-insert-sequencer-sequence
	    magit-insert-bisect-output
	    magit-insert-bisect-rest
	    magit-insert-bisect-log
	    magit-insert-untracked-files
	    magit-insert-unstaged-changes
	    magit-insert-staged-changes
	    magit-insert-stashes
	    magit-insert-unpushed-to-pushremote
	    magit-insert-unpushed-to-upstream-or-recent
	    magit-insert-unpulled-from-pushremote
	    magit-insert-unpulled-from-upstream
	    magit-insert-local-branches))
    :bind
    ("<f12> s" . 'magit-status)
    ("<f12> g" . 'counsel-git-grep))
#+end_src

** Linters
** Languages
*** Emacs Lisp
*** Python
*** C++
*** Haskell
*** Shell


* Applications
** Org Mode

I install the org-mode package very early in the init process because
I want to use a newer version than what comes with Emacs.

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-hide-emphasis-markers t)
    (org-hide-leading-stars t)
  
    :hook
    (org-mode . neo/org-mode-setup))
#+end_src

#+begin_src emacs-lisp
  (defun neo/org-mode-setup ()
    (neo/org-mode-prettify)
    (setq org-startup-indented t)
    (setq org-src-tab-acts-natively t)
    (org-indent-mode)
    (auto-fill-mode 1))
#+end_src

#+begin_src emacs-lisp
  (defun neo/org-mode-prettify ()
    (setq-default prettify-symbols-alist '(("#+BEGIN_SRC" . "†")
					   ("#+END_SRC" . "†")
					   ("#+begin_src" . "†")
					   ("#+end_src" . "†")
					   ("#+BEGIN_EXAMPLE" . (?ℰ (Br . Bl) ?⇒)) ;; ℰ⇒
					   ("#+END_EXAMPLE"    . ?⇐)               ;; ⇐
					   ("#+begin_example" . (?ℰ (Br . Bl) ?⇒)) ;; ℰ⇒
					   ("#+end_example"    . ?⇐)               ;; ⇐
					   ("#+BEGIN_QUOTE" . (?𝒬 (Br . Bl) ?⇒))   ;; 𝒬⇒
					   ("#+END_QUOTE"    . ?⇐)                 ;; ⇐
					   ("#+begin_quote" . (?𝒬 (Br . Bl) ?⇒))   ;; 𝒬⇒
					   ("#+end_quote"    . ?⇐)                 ;; ⇐
					   ("[ ]" .  "☐") 
					   ("[X]" . "☑" ) 
					   ("[-]" . "❍" ) 
					   ("<=" . ?≤)
					   (">=" . "≥")
					   ("=>" . "⇨")))
    (setq prettify-symbols-unprettify-at-point 'right-edge)
    ;; TODO there's a better way to enable this
    (prettify-symbols-mode))
#+end_src

*** Beautification

#+begin_src emacs-lisp
  (use-package org-superstar
    :custom
    (org-superstar-special-todo-items t)
    ;; not sure which setting of ~org-superstar-remove-leading-star~ I like the most
    (org-superstar-remove-leading-stars nil)
    :config
    (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
    ;; (setq org-superstar-headline-bullets-list '("☰" "☷" "☵" "☲"  "☳" "☴"  "☶"  "☱" ))
    ;; (setq org-superstar-headline-bullets-list '("✖" "✚" "◉" "○" "▶"))
    (setq org-superstar-headline-bullets-list '("◆"))
    (setq org-superstar-cycle-headline-bullets nil)
    (setq org-ellipsis " ↴ ")
    ;; TODO this is something that should be done at every theme switch.
    ;; we should have some form of hooks where we also generate a ~/.Xdefaults
    (set-face-foreground 'org-superstar-leading (face-attribute 'default :background))
    (set-face-foreground 'org-hide (face-attribute 'default :background)))
#+end_src


** Dashboard
** Calculator
** Calendar
** FIle Browser
** Shell

* Fun

* Unclassified Packages
